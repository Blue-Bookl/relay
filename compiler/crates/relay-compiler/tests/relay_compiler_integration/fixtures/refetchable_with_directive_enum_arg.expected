==================================== INPUT ====================================
# BUG: Dependency analyzer doesn't track enum usage in @refetchable directive strings.
#
# When an enum variant is removed from the schema, the incremental build should
# detect that fragments using that variant need to be rebuilt and report an error.
# However, the dependency analyzer does not track enum usage in directive string
# arguments from @refetchable(directives: [...]), so the fragment is not rebuilt
# and the stale artifact (referencing the removed STORE_AND_NETWORK variant)
# remains in the output.
#
# Expected: Incremental build fails with "Expected a value of type 'FetchPolicy'"
# Actual: Incremental build succeeds, leaving stale artifacts.

//- foo.js
graphql`
  fragment foo on User
  @refetchable(
    queryName: "FooRefetchQuery"
    directives: ["@fetchPolicy(policy: STORE_AND_NETWORK)"]
  ) {
    id
  }
`;

//- relay.config.json
{
   "language": "typescript",
   "schema": "./schema.graphql"
}

//- schema.graphql
enum FetchPolicy { STORE_AND_NETWORK, NETWORK_ONLY }
directive @fetchPolicy(policy: FetchPolicy!) on QUERY
type Query { node(id: ID!): Node }
interface Node { id: ID! }
type User implements Node { id: ID! }

//-++ schema.graphql
# Remove the STORE_AND_NETWORK variant from the enum. This should cause the
# incremental build to fail.
enum FetchPolicy { NETWORK_ONLY }
directive @fetchPolicy(policy: FetchPolicy!) on QUERY
type Query { node(id: ID!): Node }
interface Node { id: ID! }
type User implements Node { id: ID! }
==================================== OUTPUT ===================================
//- __generated__/FooRefetchQuery.graphql.ts
/**
 * <auto-generated> SignedSource<<e6d6e979af7d7329bfd928881931ddec>>
 * @lightSyntaxTransform
 * @nogrep
 */

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck

import { ConcreteRequest } from 'relay-runtime';
import { FragmentRefs } from "relay-runtime";
export type FooRefetchQuery$variables = {
  id: string;
};
export type FooRefetchQuery$data = {
  readonly node: {
    readonly " $fragmentSpreads": FragmentRefs<"foo">;
  } | null | undefined;
};
export type FooRefetchQuery = {
  response: FooRefetchQuery$data;
  variables: FooRefetchQuery$variables;
};

const node: ConcreteRequest = (function(){
var v0 = [
  {
    "defaultValue": null,
    "kind": "LocalArgument",
    "name": "id"
  }
],
v1 = [
  {
    "kind": "Variable",
    "name": "id",
    "variableName": "id"
  }
];
return {
  "fragment": {
    "argumentDefinitions": (v0/*: any*/),
    "kind": "Fragment",
    "metadata": null,
    "name": "FooRefetchQuery",
    "selections": [
      {
        "alias": null,
        "args": (v1/*: any*/),
        "concreteType": null,
        "kind": "LinkedField",
        "name": "node",
        "plural": false,
        "selections": [
          {
            "args": null,
            "kind": "FragmentSpread",
            "name": "foo"
          }
        ],
        "storageKey": null
      }
    ],
    "type": "Query",
    "abstractKey": null
  },
  "kind": "Request",
  "operation": {
    "argumentDefinitions": (v0/*: any*/),
    "kind": "Operation",
    "name": "FooRefetchQuery",
    "selections": [
      {
        "alias": null,
        "args": (v1/*: any*/),
        "concreteType": null,
        "kind": "LinkedField",
        "name": "node",
        "plural": false,
        "selections": [
          {
            "alias": null,
            "args": null,
            "kind": "ScalarField",
            "name": "__typename",
            "storageKey": null
          },
          {
            "alias": null,
            "args": null,
            "kind": "ScalarField",
            "name": "id",
            "storageKey": null
          }
        ],
        "storageKey": null
      }
    ]
  },
  "params": {
    "cacheID": "0d56defa6c9f72733aa27d2e2b12bb46",
    "id": null,
    "metadata": {},
    "name": "FooRefetchQuery",
    "operationKind": "query",
    "text": "query FooRefetchQuery(\n  $id: ID!\n) @fetchPolicy(policy: STORE_AND_NETWORK) {\n  node(id: $id) {\n    __typename\n    ...foo\n    id\n  }\n}\n\nfragment foo on User {\n  id\n}\n"
  }
};
})();

(node as any).hash = "da352f63d62b0414f1420c7f31b8121d";

export default node;

//- __generated__/foo.graphql.ts
/**
 * <auto-generated> SignedSource<<6c210813e9d169f55e16dc7e3efd0440>>
 * @lightSyntaxTransform
 * @nogrep
 */

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck

import { ReaderFragment } from 'relay-runtime';
import { FragmentRefs } from "relay-runtime";
export type foo$data = {
  readonly id: string;
  readonly " $fragmentType": "foo";
};
export type foo$key = {
  readonly " $data"?: foo$data;
  readonly " $fragmentSpreads": FragmentRefs<"foo">;
};

import FooRefetchQuery_graphql from './FooRefetchQuery.graphql';

const node: ReaderFragment = {
  "argumentDefinitions": [],
  "kind": "Fragment",
  "metadata": {
    "refetch": {
      "connection": null,
      "fragmentPathInResult": [
        "node"
      ],
      "operation": FooRefetchQuery_graphql,
      "identifierInfo": {
        "identifierField": "id",
        "identifierQueryVariableName": "id"
      }
    }
  },
  "name": "foo",
  "selections": [
    {
      "alias": null,
      "args": null,
      "kind": "ScalarField",
      "name": "id",
      "storageKey": null
    }
  ],
  "type": "User",
  "abstractKey": null
};

(node as any).hash = "da352f63d62b0414f1420c7f31b8121d";

export default node;



Artifact Map:
Project: default
  Type: Mapping
  - Source: ExecutableDefinition: foo
    Path: __generated__/FooRefetchQuery.graphql.ts
    Path: __generated__/foo.graphql.ts
